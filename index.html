<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Solid Community Server: TODO</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Solid Community Server: TODO">
  <meta name="citation_author" content="Joachim Van Herwegen" />
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Ruben Verborgh" />
  <meta name="citation_author" content="Erik Mannens" />
  
  <meta name="citation_publication_date" content="2021/10/29" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="solid-community-server-todo">Solid Community Server: TODO</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/joachimvh/" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://www.ugent.be/ea/idlab/en/members/erik-mannens.htm" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/erik_mannens">Erik Mannens</a><a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />E-mail: joachim.vanherwegen@ugent.be</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>Solid servers provide the API through which clients interface with user data.
<!-- Need         -->
Due to the diverse nature of interests in Solid,
there are many features requested from servers.
<!-- Task         -->
To meet these demands,
we have created the Solid Community server,
a modular server that can be configured to suit many needs.
<!-- Object       -->
In this paper we give an overview of the server architecture,
and how it is situated in the Solid ecosystem.
<!-- Findings     -->
Currently, there are already many parties interested in the server
and how it evolves.
<!-- Conclusion   -->
The server achieves it goal of lowering the barrier of getting started with Solid.
<!-- Perspectives -->
It will evolve together with the specification and new needs that arise.</p>

    </div>
</section>


<div class="double-column">

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Introduction</h2>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2872518.2890529"><a href="https://doi.org/10.1145/2872518.2890529">Solid</a></span> <span class="references">[<a href="#ref-1">1</a>]</span> is many things.
At the core it is a set of <a href="https://solid.github.io/specification/">API conventions</a> to facilitate
built upon the Linked Data Platform <span class="references">[<a href="#ref-2">2</a>]</span> (LDP) specification.
It adds, among other things, components such as identity, authentication and authorization.
But that is just the server component.</p>

          <p>Besides the servers, there are also the Solid applications,
which are client applications that effectively use Solid servers as a backend through the Web.
The idea there is that multiple applications can independently make use of the same server,
while still interacting with the same data.
This way a person only needs to store their personal data in a single place
which can then be reused by all applications that have need of this information.</p>

          <p>Solid is deeply a community effort: all layers influence each other.
The server API and specification naturally influence how the applications have to be developed.
On the other hand, the actual experiences of application developers
and how they experience interacting with the server
is vital in ensuring a healthy development of the environment.</p>

          <p>Due to the open source nature of Solid development,
both in available tooling and discussions being had,
everyone can cooperate to improve what is available,
which again emphasizes the community aspect of Solid.</p>

          <p>The Solid Community Server was built from the ground up to support this community aspect.
Starting from the design phase, 
the idea was always that it could be used by a multitude of users:
ranging from people who want try out this Solid thing,
to application developers that want to test out their new app against a certain setup,
to backend developers that want to set up Solid servers with specific requirements.</p>

        </div>
</section>

  <section id="requirements" inlist="" rel="schema:hasPart" resource="#requirements">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Requirements</h2>

          <p class="todo">See comunica paper for inspiration: https://comunica.github.io/Article-ISWC2018-Resource/</p>

          <p>As mentioned in <a href="#introduction">Section 1</a> the goal of the Solid Community Server is to provide
a wide spectrum of possibilities for everyone that wants to get involved with Solid,
from starting hobbyists to Solid-focused research labs,
all this while still remaining maintainable for future work.</p>

          <p>There are three different axes we wanted to cover during the design of the server,
which we will discuss below.</p>

          <h3 id="evolving-solid-specification">Evolving Solid specification</h3>
          <p>The Solid specification is still a draft specification,
meaning it can and will change in the future.
A consequence of this is that any Solid server implementation that wants to stay relevant
has to be flexible enough, so it can be updated once spec changes occur.</p>

          <h3 id="research">Research</h3>
          <p>We wanted to create a server that could be used to perform research on Solid servers,
meaning it should be easy to automate setup with a variety of different features,
such as different backends, authorization schemes, identity options, etc.</p>

          <h3 id="server-development">Server Development</h3>
          <p>No Solid server is ever going to fully support everything a user wants:
there are infinite possible combinations of features that could be required.
For this reason we wanted to ensure that the implementation allows for easy extension,
so that if, for example, a user wants the server to use their own custom backend,
they do not have to rewrite a significant part of the server logic.</p>

          <h3 id="application-development">Application Development</h3>
          <p>As mentioned before, when developing a Solid application it is vital
that the application correctly makes uses of the Solid <code>API</code>.
One of the easiest ways to ensure this is to test the app against an actual server.
To this end, we wanted the server to also be easily usable by application developers:
easy to set up, easy to configure and easy to use for their test data.</p>

        </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Related Work</h2>

          <p class="todo">Many more references</p>

          <p class="todo">Figure out what CSS does better than other solutions</p>

          <p>use more complex request (PATCH) to explain why CSS handles this better
- NSS would not be able to add ACP instead of ACL</p>

          <p>LDP is just an API, could also have SPARQL endpoint in addition</p>

          <h3 id="linked-data-platform">Linked Data Platform</h3>
          <p>apache marmotta? virtuoso? trellis?mayktso?</p>

          <h3 id="solid">Solid</h3>
          <p>ESS? NSS? PSS? reactive-solid?</p>

          <h3 id="componentsjs">Components.js</h3>
          <p>Also see configuration section</p>

          <h3 id="oidc">OIDC</h3>
          <p>webid, oidc</p>

        </div>
</section>

  <section id="architecture" inlist="" rel="schema:hasPart" resource="#architecture">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Architecture</h2>

          <p>The architecture of the server heavily makes use of dependency injection:
every class is independent of the other classes and only depends on interfaces.
This allows us to easily swap out classes for other implementations,
as long as they follow the same interface,
which provides the required flexibility mentioned in <a href="#requirements">Section 2</a>.
How we link those components together is covered in <a href="#configuration">Section 5</a>.</p>

          <p>One related aspect is that every component is responsible for solving a small problem
while being mostly unaware of the bigger picture.
This makes it so small parts get chipped of the problem of resolving a request 
until there is nothing left and the answer has been output.</p>

          <h3 id="reductive-request-processingtm">Reductive Request Processing(tm)</h3>
          <figure id="architecture-diagram" class="listing">
<pre><code>- HTTP Request -- Request Parser --&gt; Operation
</code><code>- HTTP Request -- Credentials Extractor --&gt; Credentials
</code><code>- Operation -- Modes Extractor --&gt; AccessModes
</code><code>- Credentials, Operation -- Permission Reader --&gt; Permissions
</code><code>- Credentials, Operation, Permissions -- Authorizer --&gt; Reject/Accept request
</code><code>- Operation -- Operation Handler --&gt; Response Description
</code><code>- Error -- Error Handler --&gt; Response Description
</code><code>- HTTP Response, Response Description -- Response Writer --&gt; Write HTTP Response
</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> The path an HTTP request takes through the server.</p>
            </figcaption>
</figure>

          <p class="todo">Markdown lists seem to not render as expected so should use a different format.</p>

          <p><a href="#architecture-diagram">Listing 1</a> shows a simplified overview of how an LDP request gets resolved by
being passed through several components.
It starts as an HTTP request and ends as the output is written as an HTTP response.
The steps are as follows:
1. The request is parsed into an easy-to-use Operation object 
   containing all the parsed essentials of the request.
2. We extract the credentials from the request. 
   Generally this will either be blank or the WebID identifying who is doing the request.
3. From the Operation we extract which CRUD permissions are required to resolve the request.
4. The permission reader determines what the request owner is allowed to do on the target resource.
5. The authorizer determines if the request can proceed based on the output from step 3 and 4.
6. The Operation handler resolves the Operation and generates a Response Description,
   containing everything needed to write a valid response.
    - In case any of the previous steps failed, 
      a Response Description will be generated based on the error thrown.
7. The Response Description is used to write a response.</p>

          <p>Backend data access is hidden behind a Resource Store.
This interface has functions corresponding to all the CRUD requirements.
The Operation handler in step 6 then calls the corresponding function based on the HTTP method.</p>

          <figure id="store-diagram" class="listing">
<pre><code>Operation Handler
</code><code>-&gt; (Monitoring Store)
</code><code>-&gt; (Index Store)
</code><code>-&gt; Locking Store
</code><code>-&gt; Patching Store
</code><code>-&gt; Converting Store
</code><code>-&gt; Data Accessor Store
</code><code>
</code><code>TODO: Remove bracketed stores due to less important?
</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> The stores an operation passes through before reaching the backend.</p>
            </figcaption>
</figure>

          <p>In practice, the Resource store is actually several store implementations all chained together,
as can be seen in <a href="#store-diagram">Listing 2</a>.
Each store again handles a specific a part of the complete behaviour that is expected from the store:
* The Locking store prevents multiple operations from writing to a resource at the same time.
* The Patching store handles PATCH requests.
* The Converting store converts representations to support content negotiation.
* The Data Accessor store supports LDP behaviour by calling a Data Accessor class,
  which is a simple interface to support a specific storage method.
  E.g., file based, memory based, etc.</p>

          <h3 id="patch">PATCH</h3>
          <p>One specific example of how the server makes use of smaller independent tools to solver a bigger problem
can be seen in how it handles PATCH requests.
Currently, Solid servers generally only accept PATCH request 
that contain a <a href="https://www.w3.org/TR/sparql11-update/">SPARQL UPDATE</a> body
to edit <code>RDF</code> resources.</p>

          <p>One solution for this would be to support these queries
in the same component that also handles storing the data,
seeing as we have direct access to the data there.
The disadvantage is that such an implementation 
would be required for every different storage method used,
thus also providing extra work for developers that want to
support a new storage method on the server.</p>

          <p>Our server handles this differently.
As can be seen in <a href="#store-diagram">Listing 2</a>,
we have a component specifically for handling PATCH requests.
This store first checks of the next store supports a PATCH by itself,
as could for example be the case if the storage method is a SPARQL endpoint.
But if this is not the case, this store provides a fallback method:
1. Create a new internal request to acquire the data,
   using content negotiation to request triple data.
2. Execute the SPARQL UPDATE query on the received triple data in memory.
3. Create a another internal request to write the resulting data to the resource,
   again using content-negotiation to convert back to the original media type.</p>

          <p>The converting component in this story is unaware that a PATCH request is using it,
it simply knows that it first gets a request to convert an RDF serialization to triples,
and then another request to convert triples into a serialization again.
Likewise, the backend storage only knows that it first has to return a data stream,
and afterwards has to overwrite the resource data.
On the other hand, the patching component does not know what the original data serialization was,
or how it was stored,
it can only apply a SPARQL UPDATE query on a set of triples.</p>

        </div>
</section>

  <section id="configuration" inlist="" rel="schema:hasPart" resource="#configuration">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Configuration</h2>

          <p class="todo">How much of components.js do we explain here compared to related work?</p>

          <p>talk about how imports match features to help users</p>

          <p>To combine all the independent components discussed in <a href="#architecture">Section 4</a>
we make use of the dependency injection framework <a href="https://componentsjs.readthedocs.io/">Components.js</a>,
which uses <a href="https://json-ld.org/">JSON-LD</a> configuration files to link all the components together.</p>

          <h3 id="ease-of-use">Ease of use</h3>
          <p>Components.js is a very strong framework with much flexibility,
but it does have a steep startup curve before fully understanding how configuration works.
To this end we took several steps to make configuration as easy as possible for new users.</p>

          <p>The server comes bundled with several default configurations that can be used out of the box.
These include different backends, such as file or memory based,
and examples on how to configure more complex features.</p>

          <p>Since JSON-LD is used, it is possible to split the configuration up over multiple files
and then import them into a single file.
We strongly make use of this import behaviour to hide most of the configuration complexity from new users.
Specifically, we made it so a user can choose specific features based on the files being imported.
For example, the only difference between a configuration to set up a server with a memory backend
compared to one with a file backend is that the first one imports <code>/storage/backend/memory.json</code>
and the second one imports <code>/storage/backend/file.json</code>.
This is just one of the currently 29 lines of imports that users can modify to change behaviour.
To help with the choices there, all configuration subfolders contain documentation
explaining the options available.</p>

          <p>When someone wants to develop a new component for the server,
adding Components.js configuration to link it correctly will be a requirement.
Components.js also requires configuration description files for every class,
describing the class parameters,
but the server is set up to generate those automatically using
<a href="https://github.com/LinkedSoftwareDependencies/Components-Generator.js">Components-Generator.js</a>,
saving developers much work.
Besides that, the many configurations included with the server
should help as examples of how to link components.</p>

        </div>
</section>

  <section id="usage" inlist="" rel="schema:hasPart" resource="#usage">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Usage &amp; Impact</h2>

          <h3 id="repository">Repository</h3>
          <p class="todo">Update numbers when finished</p>

          <p>At the time of writing, the <a href="https://github.com/solid/community-server">repository</a>
has 200 stars and 50 forks.
The corresponding <a href="https://gitter.im/solid/community-server">gitter</a> chatroom has 55 people.</p>

          <h3 id="maintenance">Maintenance</h3>
          <p>During the development of the server
we have always focused on making sure the code bases remained of high quality.
One way we did this is by enforcing all new code to be added through pull requests,
which always require at least one code review before being able to be merged.
This means that all code is seen by multiple people before being added.</p>

          <p>Another requirement of new code being added is that unit tests
always have 100% code coverage on all code in the project.
While this is not immediately an indication of everything working as intended,
it does make sure that a developer checks that new classes output data as expected.</p>

          <p>Besides the unit tests, we also have extensive integration tests covering the larger parts of the server.
These, for example, test all the entire Identity Provider procedures
and all the supported LDP actions.</p>

          <h3 id="projects">Projects</h3>
          <p>Some projects that other people have already made with the server:
 * Reading calendar data using a Solid server: https://github.com/KNowledgeOnWebScale/solid-calendar-store/
 * Operating Philips Hue lamps through a Solid server: https://github.com/RubenVerborgh/solid-hue/
 * Data-Kitchen, a desktop app combining local files and Solid pods: https://github.com/solid/data-kitchen/</p>

          <p class="todo">Do we explicitly have to say which projects are related to our lab?</p>

          <p class="todo">Any companies/large projects we should add? Digita? Cern? …?</p>

        </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Future Work &amp; Conclusions</h2>

          <p>We have achieved our initial goal of creation a server that has uses for a wide target audience,
as can be seen by the interest of both hobby users and companies.</p>

          <p>In the future we want to keep making sure the server adheres to the Solid specification,
but also keep extending its functionality so it becomes both more user-friendly
and has a wide array of different features it supports.</p>

          <p>One of the big challenges for the server is versioning.
We follow the <a href="https://semver.org/">semantic versioning</a> guidelines to make sure
we do not accidentally break a server installation.
For each new release, notes are added indicating both the new features 
and how configurations of older versions can be upgraded to the newer version.</p>

          <p>Due to the modular nature of the components,
it is not required for all new features to be added to the main repository.
This makes it possible for companies to develop the features that they require
and then link them to the main server,
thereby becoming the maintainers of that specific feature,
which could be part of their business model.</p>

        </div>
</section>

</main>

<footer>
  <section>
<div datatype="rdf:HTML" property="schema:description">
          <p class="todo">Mention Inrupt</p>

        </div>
</section>

  <div class="printonly" style="height: 30px">&nbsp;</div>
<section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dx.doi.org/10.1145/2872518.2890529" typeof="schema:Article">Mansour, E., Sambra, A.V., Hawke, S., Zereba, M., Capadisli, S., Ghanem, A., Aboulnaga, A., Berners-Lee, T.: A Demonstration of the Solid Platform for Social Web Applications. In: Proceedings of the 25th International Conference Companion on World Wide Web. pp. 223–226. International World Wide Web Conferences Steering Committee, Republic and Canton of Geneva, CHE (2016). doi:10.1145/2872518.2890529</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#ldp" typeof="schema:CreativeWork">Speicher, S., Malhotra, A., Arwe, J.: Linked Data Platform 1.0. W3C (2015).</dd>
</dl>
</section>
</footer>

</div>
</div>



</body>
</html>
