<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Community Solid Server: TODO</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Community Solid Server: TODO">
  <meta name="citation_author" content="Joachim Van Herwegen" />
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Erik Mannens" />
  <meta name="citation_author" content="Tim Berners-Lee" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2022/09/11" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="community-solid-server-todo">Community Solid Server: TODO</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://github.com/joachimvh/" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://www.ugent.be/ea/idlab/en/members/erik-mannens.htm" typeof="foaf:Person schema:Person" resource="https://data.verborgh.org/people/erik_mannens">Erik Mannens</a><a href="#idlab"><sup>1</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://www.w3.org/People/Berners-Lee/" typeof="foaf:Person schema:Person" resource="https://www.w3.org/People/Berners-Lee/card#i">Tim Berners-Lee</a><a href="#oxford"><sup>2</sup></a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a><a href="#idlab"><sup>1</sup></a>,<a href="#oxford"><sup>2</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />E-mail: joachim.vanherwegen@ugent.be</li>
    <li id="oxford"><sup>2</sup>University of Oxford</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Solid project aims to empower people
by giving them back control over their own data,
creating a separation between applications and data.
The goal is an environment with clear interoperability
between all solutions that adhere to the defined specification.
In essence,
Solid is a standards-driven way to extend the Linked Data vision
from public to private date, and everything in between.
<!-- Need         -->
Multiple implementations of the Solid Protocol exist,
but due to the still evolving nature of the ecosystem,
there is a strong need for an implementation that enables research into new features
and allows developers to quickly set up varying development environments.
<!-- Task         -->
To meet these demands,
we have created the Solid Community server,
a modular server that can be configured to suit many needs.
<!-- Object       -->
In this article, we give an overview of the server architecture,
and how it is positioned within the Solid ecosystem.
<!-- Findings     -->
The server supports many orthogonal feature combinations
on axes such as authorization, authentication and data storage,
and is fully compliant with the Solid specifications.
<!-- Conclusion   -->
The Community Solid Server lowers the entrance barrier to Solid.
It comes with several predefined configurations that allow developers
to quickly set up a server with different content and backends,
and can easily be modified to change many of its features.
<!-- Perspectives -->
The server will evolve together with the specification,
and we are still continuing work on adding more features that might be useful for the community,
such as adding support for cross-document queries.</p>

    </div>
</section>


<div>

<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Introduction</h2>

          <p><span class="comment" data-author="RV">TODO: the socio-economic problem Solid is solving (see my blog posts for inspiration)</span></p>

          <p><span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2872518.2890529"><a href="https://doi.org/10.1145/2872518.2890529">Solid</a></span> <span class="references">[<a href="#ref-1">1</a>]</span> is many things.
<span class="comment" data-author="RV">I think that conventions are not enough; technical specifications to achieve the aforementioned goal?</span>
At the core it is a set of <a href="https://solid.github.io/specification/">API conventions</a> to facilitate
built upon the Linked Data Platform <span class="references">[<a href="#ref-2">2</a>]</span> (LDP) specification.
<span class="comment" data-author="RV">Before describing what it adds, explain the needs of <em>why</em> this is added</span>
It adds, among other things, components such as identity, authentication and authorization.
<span class="rephrase" data-author="RV">But that is just the server component.</span></p>

          <p>Besides the servers, there are also the Solid applications,
which are client applications that effectively use Solid servers as a backend through the Web.
The idea there is that multiple applications can independently make use of the same server,
while still interacting with the same data.
<span class="comment" data-author="RV">Yes, make the point a bit more explicitly: the apps conform to the spec, the server conforms to the same spec, so any app works with any server. The browser/Apache comparison might be useful; here or already earlier.</span>
This way a person only needs to store their personal data in a single place
which can then be reused by all applications that have need of this information.</p>

          <p>Solid is deeply a community effort: all layers influence each other.
<span class="comment" data-author="RV">Which layers?</span>
The server API and specification naturally influence how the applications have to be developed.
On the other hand, the actual experiences of application developers
and how they experience interacting with the server
is vital in ensuring a healthy development of the environment.</p>

          <p>Due to the open-source nature of Solid development,
both in available tooling and discussions being had,
everyone can cooperate to improve what is available,
which again emphasizes the community aspect of Solid.</p>

          <p>The Community Solid Server was built from the ground up to support this community aspect.
Starting from the design phase, 
the idea was always that it could be used by a multitude of users:
ranging from people who want try out this Solid thing,
to application developers that want to test out their new app against a certain setup,
to backend developers that want to set up Solid servers with specific requirements.</p>

        </div>
</section>

  <section id="requirements" inlist="" rel="schema:hasPart" resource="#requirements">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Requirements</h2>

          <p class="todo">See comunica paper for inspiration: https://comunica.github.io/Article-ISWC2018-Resource/</p>

          <p>As mentioned in <a href="#introduction">Section 1</a> the goal of the Community Solid Server is to provide
a wide spectrum of possibilities for everyone that wants to get involved with Solid,
from starting hobbyists to Solid-focused research labs,
all this while still remaining maintainable for future work.</p>

          <p>There are three different axes we wanted to cover during the design of the server,
which we will discuss below.</p>

          <h3 id="evolving-solid-specification">Evolving Solid specification</h3>
          <p>The Solid specification is still a draft specification,
meaning it can and will change in the future.
A consequence of this is that any Solid server implementation that wants to stay relevant
has to be flexible enough, so it can be updated once spec changes occur.
Likewise, a modular server can be used to inform the specification:
if there is any doubt, a new module can quickly be added to assess the impact of a change.
<span class="comment" data-author="RV">That then ties into research, where we can look at designing completely different APIs and algorithms, and see how it behaves</span></p>

          <h3 id="research">Research</h3>
          <p>Solid is still growing as an ecosystem,
this includes the research that investigates all the possibilities of using Solid as a core part of a system.
This sometimes requires quickly setting up thousands of Solid servers for automation
and having flexibility in their configuration such as what storage method is used,
how authorization works,
or how user accounts are managed, for example.
<span class="comment" data-author="RV">A specific class of research (and perhaps this also ties into the next point) could be intermediaries, i.e., not just the clients and servers we’re talking about today</span></p>

          <h3 id="server-customization">Server Customization</h3>
          <p>No Solid server is ever going to fully support everything a user wants:
there are infinite possible combinations of features that could be required.
For this reason we wanted to ensure that the implementation allows for easy extension,
so that if, for example, a user wants the server to use their own custom backend,
they do not have to rewrite a significant part of the server logic.</p>

          <h3 id="application-development">Application Development</h3>
          <p>There are many things that have to be checked and kept in mind when developing a new Solid client application.
As mentioned before, it is vital that the application correctly makes use of the Solid API,
but besides that there is also a need for test users, 
testing different authorization situations,
managing different error responses, etc.
This requires testing against an actual server that provides a quick setup and teardown,
and can easily emulate different situations.</p>

          <h3 id="existing-implementations">Existing implementations</h3>

          <p class="todo">Think this makes more sense here instead of in related work?</p>

          <p class="todo">I don’t want to talk too badly about other tools :D</p>

          <p class="todo">use more complex request (PATCH) to explain why CSS handles this better?
- NSS would not be able to add ACP instead of ACL?</p>

          <p class="todo">LDP is just an API, could also have SPARQL endpoint in addition?</p>

          <p>Some existing LDP servers include <a href="https://marmotta.apache.org/">Apache Marmotta</a>,
<a href="http://vos.openlinksw.com/owiki/wiki/VOS/VirtLDP">Virtuoso</a>,
and <a href="https://github.com/trellis-ldp/trellis">Trellis</a>.</p>

          <p>There are also already several existing Solid servers,
such as <a href="https://github.com/solid/node-solid-server/">Node Solid Server</a>,
<a href="https://github.com/solid/node-solid-server/">Enterprise Solid Server</a>,
<a href="https://trinpod.us/">TrinPod</a>,
<a href="https://github.com/co-operating-systems/Reactive-SoLiD">Reactive-Solid</a>,
and several others.</p>

          <p>While they each have their own advantages and disadvantages,
none of these fulfils the requirements that we set up before though.
Specifically the customization and flexibility requirements that we have, are never fulfilled.</p>

        </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Related Work</h2>

          <p class="todo">Many more references?</p>

          <h3 id="linked-data-platform">Linked Data Platform</h3>
          <p>Linked Data Platform <span class="references">[<a href="#ref-2">2</a>]</span> (LDP) is a set of rules to provide a RESTful API
to read/write Linked Data resources on the Web.
It introduces several concepts such as using URIs to identify resources
and using RDF standards to provide information and data.</p>

          <h3 id="solid">Solid</h3>
          <p>The <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2872518.2890529"><a href="https://doi.org/10.1145/2872518.2890529">Solid</a></span> <span class="references">[<a href="#ref-1">1</a>]</span> project is a combination of <a href="https://solid.github.io/specification/">specifications</a>
with a focus on data ownership and data interoperability.
At its core is the <a href="https://solidproject.org/TR/protocol">Solid Protocol</a> specification
which determines how Solid servers should behave.
It is built upon the LDP specification and has a stricter
and more well-defined expectation for each of the CRUD operations.</p>

          <h3 id="componentsjs">Components.js</h3>
          <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.github.io/Article-System-Components/">Components.js</a> <span class="references">[<a href="#ref-3">3</a>]</span> is a Dependency Injection framework built specifically
for <a href="https://www.typescriptlang.org/">TypeScript</a> projects.
It is non-invasive in that all of its configurations happens outside the source code in external configuration files,
which describe how classes are linked to each other and which parameters they require.
These descriptions are done in RDF, which means that those configuration files are valid RDF serializations.
Usually <a href="https://json-ld.org/">JSON-LD</a> is used.</p>

          <h3 id="oidc">OIDC</h3>
          <p>To handle authentication, the server implements the <a href="https://solid.github.io/solid-oidc/">Solid-OIDC</a> specification,
which builds upon the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.17487/RFC6749"><a href="https://www.rfc-editor.org/info/rfc6749">OAuth 2.0</a></span> <span class="references">[<a href="#ref-4">4</a>]</span> and 
<a href="https://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Core 1.0</a> standards.
These are two widely adopted standards,
and the above specification extends them to solve problems specific for the Solid ecosystem.</p>

        </div>
</section>

  <section id="architecture" inlist="" rel="schema:hasPart" resource="#architecture">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Architecture</h2>

          <p><a href="#requirements">Section 2</a> explained that there is a strong need for flexibility in the server.
We want it to be possible for anyone to set up the server tailored specifically tot their needs.
We enabled this by making the codebase completely modular:
all classes are completely independent of each other and only define which interfaces they expect.
This allows anyone to easily swap out any implementation without impacting other components,
as long as they follow those same interfaces.</p>

          <h3 id="dependency-injection">Dependency Injection</h3>
          <p class="todo">This entire subsection seems to not really fit here and should perhaps be moved somewhere else.
Components.js should also have been partially described in related work already.</p>

          <p>To combine all our classes and inject their dependencies,
we make use of a Dependency Injection (DI) framework.
Such a framework injects actual implementations of the expected interfaces into the classes.
This way the actual class chains are configured externally to our implementations,
making these much easier to change.
We specifically use the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.github.io/Article-System-Components/">Components.js</a> <span class="references">[<a href="#ref-3">3</a>]</span> DI framework,
which uses declarative RDF configuration files to link everything together.
How this works in practice is covered in <a href="#configuration">Section 5</a>.</p>

          <h3 id="components">Components</h3>
          <p>Due to the nature of our DI-based architecture,
every component is mostly unaware of what its own role is in the grand scheme of things.
For example, there is a component that converts authentication headers into a usable identifier,
not knowing which component will make use of it.
There is component that converts thrown errors to serializable output,
and another simply takes incoming RDF serializations and converts them to quad objects.</p>

          <p>The combination of this architecture, combined with the DI framework, 
brings many advantages for both developers and users.</p>

          <h4 id="making-sure-the-server-correctly-implements-the-solid-protocol">Making sure the server correctly implements the Solid protocol</h4>
          <p>The Solid protocol is defined in a specification that is still evolving.
We know that it is not final and future changes are still planned.
It is important that the impact of such changes impacts a minimal amount of components.
On the one hand this makes it much easier for developers to keep the server in line with the specification.
On the other hand, this also reduces the chances of breaking any extensions
that might have been created for the server.</p>

          <h4 id="extending-the-server-features">Extending the server features</h4>
          <p>Components.js does not require the components it links together to be in the same repository.
It can import components from other projects.
This means anyone can easily extend the features of the server by writing their own modules.
In case multiple ideas need to be compared it only requires a configuration change
to set up multiple different versions of the server.
This is highly useful when doing research to evaluate different aspects,
or even as part of discussions on the Solid specification to immediately see certain suggestions in practice.</p>

          <h4 id="components-and-configurations-can-be-reused">Components and configurations can be reused</h4>
          <p>While it is possible to extend the server with custom components,
the reverse is also true: individual components of the server can be reused.
All the components are exposed through the project,
so it is possible to include only a few of them specifically if preferred.
The configurations provided with the server can also be reused,
allowing the reuse of partial blocks without having to reconfigure them completely.</p>

          <h3 id="high-level-architectural-view">High-level Architectural View</h3>
          <p class="todo">Should cover some parts of how a Solid server works in the related work as we don’t want to cover all of it here?
Should also use references instead of just links.</p>

          <p>The goal of the server is to accept incoming HTTP requests
and send a correct response based on what is defined in the Solid specification.
The specification consists of several core parts.
The community server supports these by having different components for each of them.
These can then be consecutively applied to the incoming request to reach the final result,
with each of them potentially stopping the request in case of an invalid request.
Below we cover some of these major core components.</p>

          <h4 id="authentication">Authentication</h4>
          <p>Authentication in Solid is part of the <a href="https://solid.github.io/solid-oidc/">Solid-OIDC</a> specification.
The authentication block of the server will parse the relevant headers of an incoming request
to identify the agent calling the server.
It will output the correct identifier to be used by other components.</p>

          <h4 id="authorization">Authorization</h4>
          <p>For authorization, the <a href="https://solidproject.org/TR/wac">Web Access Control</a> specification is used.
There are multiple components at work here as handling this requires several steps.
The sever has to determine which permissions are required based on the kind of request.
It also has to determine which permissions are allowed on the target resource.
A request is only valid if required permissions are allowed.</p>

          <h4 id="solid-protocol">Solid Protocol</h4>
          <p>The main Solid specification is the <a href="https://solidproject.org/TR/protocol">Solid Protocol</a>.
It is based on the Linked Data Platform <span class="references">[<a href="#ref-2">2</a>]</span> specification
and determines how different possible HTTP methods should be interpreted by the server.
There are many relevant components here as there are many possibilities here,
but the end goal is always to perform the necessary data action and return the result.</p>

          <h3 id="reductive-request-processing">Reductive Request Processing</h3>
          <p>As we mentioned before,
all the components in the server solve a specific problem
and are mostly unaware of the grander scheme of what is going on.
Requests to the server are solved by letting each component
handle a small part of the problem,
so the next component can continue and do the same,
until it has been completely solved.</p>

          <figure id="architecture-diagram" class="listing">
<pre><code>TODO: PRETTY PICTURE
</code><code>- HTTP Request -- Request Parser --&gt; Operation
</code><code>- HTTP Request -- Credentials Extractor --&gt; Credentials
</code><code>- Operation -- Modes Extractor --&gt; AccessModes
</code><code>- Credentials, Operation -- Permission Reader --&gt; Permissions
</code><code>- Credentials, Operation, Permissions -- Authorizer --&gt; Reject/Accept request
</code><code>- Operation -- Operation Handler --&gt; Response Description
</code><code>- Error -- Error Handler --&gt; Response Description
</code><code>- HTTP Response, Response Description -- Response Writer --&gt; Write HTTP Response
</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> The path an HTTP request takes through the server.</p>
            </figcaption>
</figure>

          <p><a href="#architecture-diagram">Listing 1</a> shows a simplified overview of how a request gets resolved.
It starts as an HTTP request and ends as the output is written as an HTTP response.
The steps are as follows:</p>

          <ol>
            <li>The request is parsed into an <span class="rephrase" data-author="RV">easy-to-use</span> Operation object 
containing all the parsed essentials of the request.</li>
            <li>We extract the credentials from the request. 
Generally this will either be blank or the WebID identifying who is doing the request.</li>
            <li>From the Operation we extract which CRUD permissions are required to resolve the request.</li>
            <li>The permission reader determines what the request owner is allowed to do on the target resource.</li>
            <li>The authorizer determines if the request can proceed based on the output from step 3 and 4.</li>
            <li>The Operation handler resolves the Operation and generates a Response Description,
containing everything needed to write a valid response.</li>
            <li>In case any of the previous steps failed, 
a Response Description will be generated based on the error thrown.</li>
            <li>The Response Description is used to write a response.</li>
          </ol>

          <h3 id="data-storage">Data storage</h3>
          <p>Solid does not specify how data should be stored,
only how it should be returned.
Internally we have done the same by abstracting data access with a Resource Store.
This allows us to have different stores for different storage methods,
such as in-memory, file-based or with a SPARQL endpoint.
This interface has functions corresponding to all the CRUD requirements.
In the previous subsection, the Operation handler of step 6
calls the corresponding function based on the HTTP method.</p>

          <figure id="store-diagram" class="listing">
<pre><code>TODO: PRETTY PICTURE
</code><code>Operation Handler
</code><code>-&gt; (Monitoring Store)
</code><code>-&gt; (Index Store)
</code><code>-&gt; Locking Store
</code><code>-&gt; Patching Store
</code><code>-&gt; Converting Store
</code><code>-&gt; Data Accessor Store
</code><code>
</code><code>TODO: Remove bracketed stores due to less important?
</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> The stores an operation passes through before reaching the backend.</p>
            </figcaption>
</figure>

          <p>In practice, the Resource Store is actually several store implementations all chained together,
as can be seen in <a href="#store-diagram">Listing 2</a>.
Each store again handles a specific a part of the complete behaviour that is expected from the store:</p>
          <ul>
    <li>The Locking store prevents multiple operations from writing to a resource at the same time.</li>
    <li>The Patching store handles PATCH requests.</li>
    <li>The Converting store converts representations to support content negotiation.</li>
    <li>The Data Accessor store supports LDP behaviour by calling a Data Accessor class,
      which is a simple interface to support a specific storage method.
      E.g., file based, memory based, etc.</li>
</ul>

          <h3 id="example-request-runthrough-patch">Example Request Runthrough: <code>PATCH</code></h3>
          <p>One specific example of how the server makes use of smaller independent tools to solver a bigger problem
can be seen in how it handles PATCH requests.
Currently, Solid servers generally only accept PATCH request 
that contain a <a href="https://www.w3.org/TR/sparql11-update/">SPARQL UPDATE</a> body
to edit <code>RDF</code> resources.</p>

          <p>One solution for this would be to support these queries
in the same component that also handles storing the data,
seeing as we have direct access to the data there.
The disadvantage is that such an implementation 
would be required for every different storage method used,
thus also providing extra work for developers that want to
support a new storage method on the server.</p>

          <p>Our server handles this differently.
As can be seen in <a href="#store-diagram">Listing 2</a>,
we have a component specifically for handling PATCH requests.
This store first checks of the next store supports a PATCH by itself,
as could for example be the case if the storage method is a SPARQL endpoint.
But if this is not the case, this store provides a fallback method:
1. Create a new internal request to acquire the data,
   using content negotiation to request triple data.
2. Execute the SPARQL UPDATE query on the received triple data in memory.
3. Create a another internal request to write the resulting data to the resource,
   again using content-negotiation to convert back to the original media type.</p>

          <p>The converting component in this story is unaware that a PATCH request is using it,
it simply knows that it first gets a request to convert an RDF serialization to triples,
and then another request to convert triples into a serialization again.
Likewise, the backend storage only knows that it first has to return a data stream,
and afterwards has to overwrite the resource data.
On the other hand, the patching component does not know what the original data serialization was,
or how it was stored,
it can only apply a SPARQL UPDATE query on a set of triples.</p>

        </div>
</section>

  <section id="configuration" inlist="" rel="schema:hasPart" resource="#configuration">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Configuration</h2>

          <p>As mentioned in <a href="#related-work">Section 3</a>,
the server makes use of the Dependency Injection framework <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkedsoftwaredependencies.github.io/Article-System-Components/">Components.js</a> <span class="references">[<a href="#ref-3">3</a>]</span>
This allows us to combine all the independent components discussed in <a href="#architecture">Section 4</a>.</p>

          <p>It is a framework with much flexibility and options,
but it does have a steep startup curve before fully understanding how configuration works.
To this end we took several steps to make configuration as easy as possible for new users.</p>

          <h3 id="default-configurations">Default configurations</h3>

          <p>Due to the external nature of the configurations,
Components.js allows us to provide many different versions of the server to the users.</p>

          <p>The server comes bundled with several 
<a href="https://github.com/CommunitySolidServer/CommunitySolidServer/tree/main/config">default configurations</a> 
that can be used out of the box.
These include different backends, such as file or memory based,
and examples on how to configure more complex features.</p>

          <p>These default configurations cover the main use cases of many users,
and those who do want to configure a different experience can often achieve this by only making minor adjustments.</p>

          <h3 id="feature-options">Feature options</h3>

          <p>Since RDF is used, it is possible to split the configuration up over multiple files
and then import them into a single file.
We strongly make use of this import behaviour to hide most of the configuration complexity from new users.
Specifically, we made it so a user can choose specific features based on the files being imported.
For example, the only difference between a configuration to set up a server with a memory backend
compared to one with a file backend is that the first one imports <code>/storage/backend/memory.json</code>
and the second one imports <code>/storage/backend/file.json</code>.
This is just one of the imports that users can modify to change behaviour.
To help with the choices there, there is documentation explaining all the available options.</p>

          <h3 id="configuring-extensions">Configuring extensions</h3>

          <p>When someone wants to develop a new component for the server,
adding Components.js configuration to link it correctly will be a requirement.
Components.js also requires configuration description files for every class,
describing the class parameters,
but the server is set up to generate those automatically using
<a href="https://github.com/LinkedSoftwareDependencies/Components-Generator.js">Components-Generator.js</a>,
saving developers much work.
Besides that, the many configurations included with the server
should help as examples of how to link components.</p>

        </div>
</section>

  <section id="usage" inlist="" rel="schema:hasPart" resource="#usage">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Usage &amp; Impact</h2>

          <h3 id="repository">Repository</h3>
          <p class="todo">Update numbers when finished</p>

          <p>At the time of writing, the <a href="https://github.com/CommunitySolidServer/CommunitySolidServer">repository</a>
has 288 stars and 72 forks.
The corresponding <a href="https://gitter.im/CommunitySolidServer/community">gitter</a> chatroom has 32 people.</p>

          <h3 id="maintenance">Maintenance</h3>
          <p>During the development of the server
we have always focused on making sure the code bases remained of high quality.
One way we did this is by requiring the unit tests 
to always have 100% code coverage on all code in the project.
While this is not immediately an indication of everything working as intended,
it does make sure that a developer checks that new classes output data as expected.</p>

          <p>Another requirement is that all new code needs to be added through pull requests,
which always require at least one code review before being able to be merged.
This means that all code is seen by multiple people before being added.</p>

          <p>Besides the unit tests, we also have extensive integration tests covering the larger parts of the server.
These, for example, test all the entire Identity Provider procedures
and all the supported LDP actions.</p>

          <h3 id="projects">Projects</h3>
          <p>Some projects that other people have already made with the server:</p>
          <ul>
  <li>Reading calendar data using a Solid server: https://github.com/KNowledgeOnWebScale/solid-calendar-store/</li>
  <li>Operating Philips Hue lamps through a Solid server: https://github.com/RubenVerborgh/solid-hue/</li>
  <li>Data-Kitchen, a desktop app combining local files and Solid pods: https://github.com/solid/data-kitchen/</li>
  <li>Solid-Redis, a component for the server to use Redis as data storage: https://github.com/comake/solid-redis</li>
</ul>

          <p><a href="https://get.use.id/">use.id</a> is an example of a commercial product that was built using the server.</p>

          <p class="todo">Make sure this URL (and many others) also appear in the printed version.</p>

          <p><span class="comment" data-author="RV">And all apps that work on the server?</span>
<span class="comment" data-author="JVH">Do you mean Solid client apps? Will have to investigate which ones are up to date enough to work. Media Kraken and Mashlib are at least 2.</span></p>

          <p class="todo">Do we explicitly have to say which projects are related to our lab?</p>

        </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
          <h2 property="schema:name">Future Work &amp; Conclusions</h2>

          <p>We have achieved our initial goal of creation a server that has uses for a wide target audience,
as can be seen by the interest of both hobby and expert users.</p>

          <p>In the future we want to keep making sure the server adheres to the Solid specification,
but also keep extending its functionality so it becomes both more user-friendly
and has a wide array of different features it supports.</p>

          <p>One of the big challenges for the server is versioning.
We follow the <a href="https://semver.org/">semantic versioning</a> guidelines to make sure
we do not break any server installation.
For each new release, notes are added indicating both the new features 
and how configurations of older versions can be upgraded to the newer version.
Since all classes and configurations are part of the public API of the package,
most changes immediately require a major version increase,
which causes a faster upgrade cycle.</p>

          <p>Due to the modular nature of the components,
it is not required for all new features to be added to the main repository.
This makes it possible for companies to develop the features that they require
and then link them to the main server,
thereby becoming the maintainers of that specific feature,
which could be part of their business model.</p>

        </div>
</section>

</main>

<footer>
  <section>
<div datatype="rdf:HTML" property="schema:description">
          <p class="todo">Mention Inrupt</p>

        </div>
</section>

  <div class="printonly" style="height: 30px">&nbsp;</div>
<section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dx.doi.org/10.1145/2872518.2890529" typeof="schema:Article">Mansour, E., Sambra, A.V., Hawke, S., Zereba, M., Capadisli, S., Ghanem, A., Aboulnaga, A., Berners-Lee, T.: A Demonstration of the Solid Platform for Social Web Applications. In: Proceedings of the 25th International Conference Companion on World Wide Web. pp. 223–226. International World Wide Web Conferences Steering Committee, Republic and Canton of Geneva, CHE (2016). doi:10.1145/2872518.2890529</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#ldp" typeof="schema:CreativeWork">Speicher, S., Malhotra, A., Arwe, J.: Linked Data Platform 1.0. W3C (2015).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://linkedsoftwaredependencies.github.io/Article-System-Components/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Components.js: Semantic Dependency Injection. Semantic Web Journal. (2022).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://dx.doi.org/10.17487/RFC6749" typeof="schema:CreativeWork">Hardt, D.: The OAuth 2.0 Authorization Framework. <a href="https://www.rfc-editor.org/info/rfc6749">https:/​/​www.rfc-editor.org/info/rfc6749</a> (2012). doi:10.17487/RFC6749</dd>
</dl>
</section>
</footer>

</div>
</div>



</body>
</html>
